---
title: "Análisis de Biodiversidad Marina: Pipeline Integrado para Conservación y Evolución"
subtitle: "Reporte Técnico de Análisis Espacial y Evolutivo de Especies Marinas"
date: "`r Sys.Date()`"
author:
  - name: Santiago García Ríos
    degrees: 
      - Biólogo
      - Maestro en C. (trámite)
    roles: "Conceived and designed the study, analysed the results and wrote the manuscript."
    orcid: 0000-0001-6237-9616
    email: santiago_gr@ciencias.unam.mx
    phone: 55-81-07-99-11
    url: https://santi-rios.github.io/
    affiliation: 
      - name: Universidad Nacional Autónoma de México
        city: Ciudad de México
abstract: > 
  Este reporte presenta los resultados del pipeline integrado de análisis de biodiversidad marina, enfocado en la conservación y evolución de especies marinas del Caribe. El análisis incluye datos de ocurrencia de múltiples fuentes, validación de coordenadas, modelado de idoneidad de hábitat, y análisis espacial comprehensivo. Combina tres herramientas clave de manera muy efectiva: Make como orquestador, Nix (a través de rix) como gestor del ambiente computacional y {targets} para la gestión de la pipeline de análisis.
  - Biodiversidad
  - Pipeline
license:
  text: >
    The code in this repository is licensed under MIT License and the academic quarto report is licensed under CC BY 4.0
  type: open-access
  url: https://www.gnu.org/licenses/fdl-1.3-standalone.html
copyright: 
  holder: Santiago Garcia-Rios
  year: 2025
citation: 
  container-title: NereidaPipeline
  volume: 1
  issue: 1
  doi: 10.xxxx/xxxxxxxxx
format:
  html:
    # title
    title-block-banner: "../figures/banner.png"
    title-block-banner-color: white
    # toc
    toc: true
    toc-depth: 3
    toc-location: body
    number-sections: true
    anchor-sections: true
    # code
    code-fold: true
    code-copy: true
    # code-link: true
    code-tools: true
    # figures and links
    lightbox: true
    link-external-icon: true
    # theme
    theme: cosmo
    # css: styles.css
    # render
    embed-resources: true
execute: 
  echo: false
  warning: false
  message: false 
bibliography: "../referencias/referencias.bib"
lang: es
---

<!-- TODO: CV orcid y PDF y https://santi-rios.github.io/ -->

<!-- TODO: fetch articles https://www.icmyl.unam.mx/es/quienes-somos/publicaciones-del-instituto -->

<!-- TODO: ensamble biomatr -->

<!-- TODO: https://roxygen2.r-lib.org/ -->

<!-- TODO: jupyter -->

```{r}
#| label: setup
#| include: false

# Cargar paquetes necesarios para el reporte
suppressPackageStartupMessages({
  library(targets)
  library(dplyr)
  library(knitr)
  library(DT)
  library(plotly)
  library(leaflet)
  library(ggplot2)
  library(tidyr)
  library(kableExtra)
})

# Cargar los objetos del pipeline de targets necesarios para el reporte.
# tar_quarto() detectará estas dependencias y ejecutará este reporte
# solo cuando los objetos cambien.
tar_load(
  c(
    "obis_occurrences",
    "gbif_occurrences",
    "cleaned_occurrences",
    "spatial_analysis",
    "habitat_models",
    "data_summaries",
    "pipeline_report",
    "genome_availability",
    "genomic_sequences",
    "genomic_quality"
  )
)

# Crear el objeto 'loaded_targets' para verificar la disponibilidad
target_names <- c(
  "obis_occurrences",
  "gbif_occurrences",
  "cleaned_occurrences",
  "spatial_analysis",
  "habitat_models",
  "data_summaries",
  "pipeline_report"
)
loaded_targets <- sapply(target_names, exists, simplify = FALSE)


# Configuración de Knitr
knitr::opts_chunk$set(
  fig.width = 10,
  fig.height = 7,
  dpi = 300,
  out.width = "100%"
)

# Función auxiliar para verificar si un objeto existe y tiene datos
safe_check <- function(obj_name) {
  exists(obj_name) && !is.null(get(obj_name)) &&
  (if (is.data.frame(get(obj_name))) nrow(get(obj_name)) > 0 else TRUE) &&
  (if (is.list(get(obj_name))) length(get(obj_name)) > 0 else TRUE)
}

```


# Introducción

La biodiversidad marina enfrenta amenazas sin precedentes debido al cambio climático, la acidificación oceánica, y las actividades antropogénicas. Este análisis utiliza un pipeline integrado que combina múltiples fuentes de datos y métodos analíticos avanzados para evaluar el estado de conservación y los patrones evolutivos de especies marinas clave.

La robustez metodológica es tan importante como los resultados mismos, especialmente en campos como la biología de la conservación y la evolución, donde las decisiones pueden tener implicaciones a largo plazo y deben basarse en evidencia auditable y reproducible.

## Ciencias Multiómicas

Multiómicos se refiere a un enfoque de investigación que integra datos de múltiples disciplinas "ómicas" (como la genómica, proteómica, transcriptómica, etc.) para obtener una comprensión más completa y holística de un sistema biológico, enfermedad o proceso celular. Al combinar estos diferentes niveles moleculares, los estudios multiómicos permiten inferir mecanismos biológicos subyacentes de manera más precisa, desentrañar las causas de fenómenos complejos y descubrir biomarcadores. 

Ómicas clave que se integran:

- Genómica: Estudio de los genes y su variación. 
- Transcriptómica: Estudio de los ARN mensajeros (ARNm) para entender la expresión génica. 
- Proteómica: Estudio de las proteínas, sus estructuras y funciones. 
- Metabolómica: Estudio de los metabolitos y cómo interactúan. 
- Epigenómica: Estudio de los cambios heredables en la expresión génica sin alterar la secuencia de ADN. 
- Microbioma: Estudio de las comunidades microbianas y su impacto en el huésped. 


## El Paradigma de la Investigación Reproducible

> Establecer el marco conceptual y la necesidad urgente de la reproducibilidad computacional en las ciencias, particularmente en ecología y evolución.

[@noble2009]: The core guiding principle is simple: Someone unfamiliar with your project should be able to look at your computer files and understand in detail what you did and why. This ‘‘someone’’ could be any.

[@dolstra2006]: The development of principles and tools to support the deployment process has largely been relegated to industry, system administrators, and Unix hackers. This has resulted in a large number of often ad hoc tools that typically automate manual practices but do not address fundamental issues in a systematic and disciplined way. This is evidenced by the huge number of mailing list and forum postings about deployment failures, ranging from applications not working due to missing dependencies, to subtle malfunctions caused by incompatible components. Deployment problems also seem curiously resistant to automation: the same concrete problems appear time and again. Deployment is especially difficult in heavily component-based systems—such as Unix-based open source software—because the effort of dealing with the dependencies can increase super-linearly with each additional dependency. This work describes a system for software deployment called Nix (trough '{rix}-r package') that addresses many of the problems that plague existing deployment systems.

[@wilson2017]: Este artículo Justifica la necesidad de prácticas como la automatización de flujos de trabajo (e este proyecto usamos herramientas como `Make` y `{targets}`) y el seguimiento de versiones del software (lo que logra con `Nix`). Argumentar que su metodología no es una complejidad innecesaria, sino una adhesión a las "buenas prácticas" recomendadas por la comunidad científica para evitar errores y asegurar la longevidad de los resultados.

[@marwick2018]: Este artículo aborda directamente el ecosistema de R. Explica cómo empaquetar un proyecto de análisis de datos (código, datos y el ambiente computacional) para hacerlo reproducible. Proporciona el argumento académico perfecto para justificar por qué usar una herramienta como `Nix` (a través de `rix`) es una solución superior a simplemente listar los paquetes, ya que captura el estado completo del sistema.

## Gestión del Ambiente Computacional con Nix

Estas referencias validan el uso de gestores de ambientes declarativos como Nix para garantizar la reproducibilidad a nivel de software.

[@dolstra2006]: Esta es la fuente original que describe el modelo detrás de Nix. Es una referencia más técnica, pero citarla demuestra un profundo entendimiento de los fundamentos de su flujo de trabajo. Puede usarla para afirmar que su proyecto se basa en un "modelo puramente funcional" que garantiza la construcción de ambientes computacionales determinísticos, eliminando problemas comunes como el "funciona en mi máquina".

Abogar por herramientas como Nix para resolver la "crisis de reproducibilidad" en campos computacionalmente intensivos. Citar este artículo le permite establecer un paralelismo, argumentando que, al igual que en la neurociencia, la complejidad del análisis de datos genómicos, espaciales y taxonómicos en la conservación marina exige soluciones de reproducibilidad robustas.


### Manejo de ambientes: Nix vs otras opciones

Utilizar 'Nix' mediante el paquete 'rix' es una opción más robusta para gestionar entornos científicos y pipelines frente a herramientas como 'conda' o 'renv'. Se incluye una tabla comparativa seguida de una breve recomendación de uso.


| Criterio / Aspecto | Nix (con rix) | Conda | renv |
|---|---:|---:|---:|
| Reproducibilidad determinista | Muy alta. Nix es declarativo e inmune a cambios del sistema; rix genera expresiones reproducibles para R y deps del sistema. | Moderada. Conda puede registrar versiones, pero la resolución de dependencias y canales introduce variabilidad. | Parcial. Fija versiones de paquetes R (lockfile) pero no gestiona dependencias del sistema nativas. |
| Gestión de dependencias del sistema (C, libs, binarios) | Nativa y exhaustiva. Nix declara y proporciona librerías del sistema de forma aislada. | Buena (conda-forge), pero limitada para ciertos paquetes del sistema y con problemas de enlaces dinámicos. | Ninguna. Depende del SO o de gestores externos; riesgo de “works on my machine”. |
| Aislamiento / hermeticidad | Alto: entornos aislados en la store de Nix; evita contaminación por el entorno del usuario. | Aislado a nivel de entorno, pero puede verse afectado por bibliotecas del sistema; problemas con PATH/LD_LIBRARY_PATH. | No a nivel de sistema; sólo controla paquetes R dentro del proyecto. |
| Declaratividad y trazabilidad | Declarativo (nix expressions). Fácil de versionar, auditar y reconstruir. | Declarativo limitado (environment.yml), pero resolución no determinista entre ejecuciones. | Declarativo para R (renv.lock) pero sin trazabilidad de libs externas. |
| Integración con CI / archivado a largo plazo | Excelente: reconstrucción reproducible en CI; uso de cachés binarios; apto para archivado y publicación de entornos. | Buena en CI, pero reproducibilidad exacta depende de canales y binarios disponibles. | Adecuado para reproducir entornos R en el corto/medio plazo; falla si faltan deps del sistema. |
| Compatibilidad multi-lenguaje | Sí, gestiona todo el stack (R, Python, C, system tools) en un único lenguaje de especificación. | Buena (R, Python, otros), pero fragmentación en canales. | Enfocado a R; no gestiona otros lenguajes de forma integrada. |
| Facilidad de uso / curva de aprendizaje | Moderada a alta. rix reduce la barrera para usuarios de R pero Nix tiene conceptos nuevos. | Baja (fácil de empezar). Muy accesible para usuarios nuevos. | Muy baja — transparente para usuarios R; fácil de incorporar. |
| Tamaño / consumo de disco | Amplio (store de Nix), pero con beneficios de caché y deduplicación entre proyectos. | Variable; entornos duplicados pueden consumir mucho. | Ligero (solo paquetes R), pero requiere deps del sistema por separado. |
| Limitaciones notables | Curva de aprendizaje; en Windows requiere WSL o soluciones; rix aún evoluciona. | Canales y resolución crean incoherencias; algunos paquetes de sistema difíciles. | No asegura reproducibilidad completa (falta libs del SO); no declara sistema. |
| Uso recomendado | Pipelines reproducibles, CI/archivado, proyectos con dependencias R + sistema, entornos multi-lenguaje y producción. | Entornos ad-hoc, exploración rápida, usuarios que necesitan rápidos “envs” multiplataforma. | Desarrollo R colaborativo rápido, lockfiles para paquetes R, proyectos que delegan deps del SO a otra solución. |


::: {.callout-tip}

**Uso de 'conda' + 'Nix' ('{rix}')**

- Es posible usar conda dentro de un entorno generado con 'rix/Nix': 'Nix' puede instalar paquetes del ecosistema 'conda' (p. ej. 'miniconda3') y ejecutar comandos conda desde el 'shell' que 'Nix' provee. 'rix', al final, genera expresiones 'Nix'; en esas expresiones se pueden declarar paquetes del sistema como "'miniconda3'" o "'mamba'" y añadir un 'shell_hook' para crear/activar un entorno conda/'conda-env' al entrar al 'nix-shell'.  
- Sin embargo, en términos de reproducibilidad y coherencia, incluir 'conda' dentro de 'Nix' es en gran medida **redundante** y atenta contra las garantías que 'Nix' aporta: 'conda' genera entornos que no son $100\%$ declarativos ni bit-reproducibles (resolución de dependencias y artefactos binarios dependen de servidores externos). Por ello, el patrón recomendado es gestionar 'Python' y sus binarios desde 'Nix' ('nixpkgs') siempre que sea posible; solo recurrir a conda cuando exista una dependencia binaria crítica que no esté disponible en 'nixpkgs' o cuando el equipo ya dependa fuertemente de 'conda' y se acepte la pérdida parcial de determinismo.

**Gestión de dependencias del sistema**

- 'rix/Nix' gestiona paquetes de sistema ('git', 'libssl', binarios 'C/Fortran') de forma nativa y declarativa. 'Conda' (especialmente 'conda-forge') puede proveer muchos paquetes binarios ('python', librerías científicas), pero no sustituye a un gestor de sistema para librerías del sistema (p. ej. 'glibc', versiones del compilador) y su resolución depende de canales; por tanto, no iguala la hermeticidad ni la trazabilidad de 'Nix'.

**Recomendaciones prácticas y consideraciones**

- Preferible: declarar 'Python' y paquetes 'Python' directamente en 'Nix' (usar paquetes 'python' de 'nixpkgs' o 'poetry2nix/pypi2nix'), o usar 'mamba/conda' dentro de 'Nix' solo para casos puntuales.
- Ventaja: entornos completamente reconstruibles en 'CI' y archivables con la expresión 'Nix'.
- Si se incorpora 'conda' dentro de 'Nix': incluir 'miniconda/mamba' como 'system_pkgs' en 'rix()' y 'use shell_hook' para crear/activar un entorno 'conda' desde un 'environment.yml' almacenado en el repositorio. Documentar explícitamente este paso y aceptar las limitaciones de determinismo.
- 'Conda' puede instalar muchos paquetes “del sistema” (a través de 'conda-forge'), pero no gestiona el sistema base ni garantiza identicidad binaria entre máquinas; 'Nix' sí lo hace.

Ejemplo práctico 

— modificación sugerida de' build_env.R' (opcional: integrar 'conda/miniconda' y crear env al entrar al 'nix-shell'):

````r
# ...existing code...
rix(
  r_ver = "latest-upstream",
  r_pkgs = all_packages,
-  system_pkgs = c("git", "python3", "quarto"),
+  # Incluir miniconda3 si se necesita usar conda dentro del entorno Nix.
+  # Alternativa recomendada: gestionar Python desde nixpkgs (evita redundancia).
+  system_pkgs = c("git", "python3", "quarto", "miniconda3"),
-  tex_pkgs = c("amsmath"),
-  ide = "none",
-  shell_hook = "",
+  tex_pkgs = c("amsmath"),
+  ide = "none",
+  # Ejemplo de shell_hook que crea/actualiza un entorno conda local a partir de environment.yml.
+  # Nota: esto ejecuta conda al entrar al nix-shell; la reproducibilidad del entorno conda
+  # depende de conda/mamba y de los canales usados.
+  shell_hook = '
+if [ -f environment.yml ]; then
+  if [ ! -d ".conda-env" ]; then
+    echo "Creando entorno conda local (.conda-env) desde environment.yml..."
+    conda env create -p ./.conda-env -f environment.yml || conda env update -p ./.conda-env -f environment.yml
+  fi
+  export PATH="$(pwd)/.conda-env/bin:$PATH"
+fi
+',
  project_path = ".",
  overwrite = TRUE,
  print = TRUE
)
# ...existing code...
````

Caveats técnicos y cierre

- Mezclar 'Nix + conda' es factible pero introduce una capa menos declarativa ('conda'). Para reproducibilidad académica estricta, preferir 'Nix-native' ('nixpkgs/pypi2nix/poetry2nix').
Si se necesita 'conda' por razones prácticas (paquetes no disponibles en 'nixpkgs', flujo de trabajo del equipo), documentar la receta ('environment.yml', comando de creación) y versionar el archivo junto al proyecto; idealmente incorporar la creación del entorno ''conda'' en 'CI' para asegurar consistencia operativa aunque no absoluta bit-reproducible.
'Nix' (por medio de 'rix') gestiona 'git' y otras dependencias del sistema de forma nativa y declarativa; 'conda' puede proveer muchos binarios pero no reemplaza la gestión total de librerías del sistema ni ofrece la misma trazabilidad. 

:::


## Pipelines

La gestión de la pipeline es crucial para la eficiencia y la corrección de los análisis complejos. `

[@landau2021]: Esta es la cita oficial y directa del paquete `{targets}`. Es indispensable. Úsela para introducir la herramienta, explicando que su elección se basa en una solución documentada y revisada por pares diseñada específicamente para crear pipelines de análisis reproducibles y eficientes en R. Resalte características clave que el artículo menciona, como el seguimiento de dependencias y el paralelismo, que son cruciales para análisis a gran escala en conservación.


## Control de versiones

[@noble2009]: Record every operation that you perform. 2. Comment generously. . Avoid editing intermediate files by hand. Use relative pathnames to access other files within the same project. perhaps most significantly, version control is invaluable for collaborative projects. The repository allows collaborators to work simultaneously on a collection of files, including scripts, documentation, or a draft manuscript. If two individuals edit the same file in parallel, then the version control software will automatically merge the two versions and flag lines that were edited by both people.

# Objetivos

1. **Integrar datos de ocurrencia** de múltiples fuentes (OBIS, GBIF)
2. **Validar y limpiar** coordenadas geográficas usando métodos estandarizados
3. **Analizar patrones espaciales** de distribución de especies marinas
4. **Modelar idoneidad de hábitat** considerando variables ambientales
5. **Generar recomendaciones** para conservación basadas en evidencia

# Planteamiento del problema

¿Por qué es importante la multiómica? Proporciona una perspectiva más completa de un sistema biológico en lugar de solo estudiar componentes aislados. Sin embargo, es la Integración de datos complejos, los cuales Permiten integrar y analizar grandes volúmenes de datos generados por diferentes tecnologías de alto rendimiento, no suele ser un paso sencillo.

For example, Next-Generation-Sequencing (NGS) bioinformatics uses computational tools, software, and algorithms to process and analyze the massive datasets generated by Next-Generation Sequencing (NGS). It involves cleaning and aligning millions of DNA or RNA fragments to reconstruct genomes or transcriptomes, identifying genetic variants like mutations, and annotating these variants to understand their biological significance. It is essential to consider: Data Processing: Raw sequence reads from NGS instruments are complex and need to be cleaned, aligned to a reference genome, and assembled to form longer sequences. Variant Calling and Annotation: The process identifies genetic variations (such as single nucleotide polymorphisms or structural variations) and adds information about these variants' potential functions or links to disease. Interpretation and Visualization: The analyzed data is presented in user-friendly formats like reports and visualizations, allowing researchers and clinicians to make informed decisions. 

[@dolstra2006]: Software deployment is the problem of managing the distribution of software to end-user machines. That is, a developer has created some piece of software, and this ultimately has to end up on the machines of end-users. After the initial installation of the software, it might need to be upgraded or uninstalled. Presumably, the developer has tested the software and found it to work sufficiently well, so the challenge is to make sure that the software works just as well, i.e., the same, on the end-user machines. I will informally refer to this as correct deployment: given identical inputs, the software should behave the same on an end-user machine as on the developer machine1. This should be a simple problem. For instance, if the software consists of a set of files, then deployment should be a simple matter of copying those to the target machines. In practice, deployment turns out to be much harder. This has a number of causes. These fall into two broad categories: environment issues and manageability issues. Even worse, the component might be dependent on a specific compiler, or on specific compilation options being used for its dependencies. This is often a rather labour-intensive part of the deployment process. 

[@dolstra2006]: the Nix deployment system, which overcomes the limitations of contemporary deployment tools described above. It solves implementation (how it works), the underlying principles (why it works), our experiences and empirical validation (that it works), and the application areas to which it can be applied (where it works).

La gestión de la pipeline es crucial para la eficiencia y la corrección de los análisis complejos. `{targets}` es el estándar moderno en el ecosistema R.

[@landau2021]: Esta es la cita oficial y directa del paquete `{targets}`. Es indispensable. Úsela para introducir la herramienta, explicando que su elección se basa en una solución documentada y revisada por pares diseñada específicamente para crear pipelines de análisis reproducibles y eficientes en R. Resalte características clave que el artículo menciona, como el seguimiento de dependencias y el paralelismo, que son cruciales para análisis a gran escala en conservación.

[@noble2009]: A few months from now, you may not remember what you were up to when you created a particular set of files, or you may not remember what you drew. You will either have to then spend time reconstructing your previous experiments or lose whatever insights you gained from those experiments.

[@noble2009]: it is important to handle long-running scrips and its outputs. The final line of a runall script calls summarize, which in turn creates a plot, table, or HTML page that summarizes the results of the experiment (in our case, we use quarto for this). The summarize script is written in such a way that it can interpret a partially completed experiment, showing how much of the computation has been performed thus far.

[@boyle2009]: changes in software engineering and design include: the methodology through which software is constructed (e.g. components leading to frameworks, and frameworks leading to aspects [1]); the technology used to allow for distributed computing (e.g. object brokers evolving pass-byvalue mechanisms, and these being replaced by stateless Web Services); and the ideology that is used to define the process through which software is built (e.g. the "rational" processes being replaced by agile programming).

[@noble2009]:In addition, the need to make results accessible to and understandable by wet lab biologists may have practical implications for how a project is managed. For example, to make the results more understandable, significant effort may need to go into the prose descriptions of experiments in the lab notebook, rather than simply including a figure or table with a few lines of text summarizing the major conclusion. More practically, differences in operating systems and software may cause logistical difficulties. For example, computer scientists may prefer to write their documents in the LaTeX typesetting language, whereas biologists may prefer Microsoft Word.

Generación de reportes técnicos con Quarto
Scholarly articles require much more detail in their front matter than simply a title and an author. Quarto provides a rich set of YAML metadata keys to describe these details. On this page, you’ll learn how to specify authors and their affiliations, article summaries like an abstract and keywords, and how to include information on copyright, licensing and funding.

Lastly, data integrity, accesibility, and size as it grows requieres more than cvs files in an academic context. 

[@boyle2009]: database based solutions to open, distributed, interoperable data management solutions (see Figure 1). This change has been driven by demands for rapid development, high levels of interoperability and increases in data volume and complexity.

# Metodología

## Crear el ambiente con Nix

El paquete R {rix} 'r library(rix)', en línea con este enfoque, permite una integración simplificada de Nix en la plataforma R. Esto significa que las dependencias de R, del sistema y el control de versiones pueden ser gestionados de forma centralizada a través de Nix. La inclusión de {rix} en este proyecto permite el manejo eficiente de las dependencias de R de manera reproducible (Gabay et al., 2019).

En conclusión, la fundamentación del proyecto en la integración de R, Nix y el paquete {rix} se traduce en una robustez y una gestión optimizada de las dependencias, facilitando notablemente el procesamiento y el análisis de datos y el manejo de código. Además, permite la integración eficiente de información en repositorios y proporciona un entorno de trabajo reproducible, lo cual es vital para mantener la validez y la replicabilidad de las investigaciones científicas.

## Automatización de Pipelines con `{targets}`

La gestión de la pipeline es crucial para la eficiencia y la corrección de los análisis complejos. `{targets}` es el estándar moderno en el ecosistema R.

## Orquestación del Flujo de Trabajo con `Make`

El uso de `Make` como un "orquestador" de alto nivel simplifica la interacción y estandariza los procedimientos.

[@noble2009]: Este influyente artículo describe las mejores prácticas para organizar proyectos de biología computacional. Recomienda explícitamente el uso de `Make` para automatizar la pipeline, desde la descarga de datos hasta la generación de figuras finales. Citarlo posiciona su uso de `Makefile` como una práctica establecida y recomendada para mantener la organización, la claridad y la automatización en proyectos complejos, lo cual es vital en estudios integrativos de biodiversidad marina.

## Preparación de librerías

DNA or RNA is fragmen                                                                       ted and prepared for sequencing by adding sequencing adapters.

Sequencing: The prepared samples are run on high-throughput sequencing machines to generate millions of short reads.

Primary Analysis: Raw sequence data is converted into FASTQ files, which contain sequence data and quality scores. 

Secondary Analysis: Reads are aligned to a reference genome, and variants are identified and annotated. 

Tertiary Analysis: The identified variants are interpreted for their potential impact on biological pathways and phenotypes, often by querying genomic databases. 

### biomatr: Adquisición de Datos ómicos

Se utilizó el paquete 'r library(biomatr)', que nos permite obtener datos de organismos de múltiples bases de datos (RefSeq, GenBank, or Ensembl)

Multiple data types: Genome, proteome, CDS, GFF, RNA
Availability checking: Check what's available before downloading
Assembly stats: Get quality metrics for assemblies
Better error handling: Clear messages about what's available and what failed.

Implementamos este paquete de tal manera que:

when you run the pipeline:

It will check all databases (refseq, genbank, ensembl)
Generate a comprehensive availability report
Download all available data
Assess data quality
Generate a beautiful HTML report with:
Species information
Database availability tables
Success/failure summaries
Data size statistics
Visual heatmaps
Proper citations for all software and data sources
The report will be saved as reports/genomic_data_retrieval.html and can be opened in any browser!

### Functional annotation 

Extract GO terms and protein domains from the successfully retrieved A. palmata data
Sequence statistics - Analyze the proteome and CDS sequences

Extract GO terms and protein domains from the successfully retrieved A. palmata data

### sequence statistics 

Analyze the proteome and CDS sequences

### Sequence Analysis

Use the retrieved sequences for comparative genomics
Functional Annotation - Extract GO terms and protein domains

### Homology Analysis

Find orthologs across species

### myTAI: Phylogenetic Analysis

Use  for evolutionary transcriptomics


### metagenomics

- https://academic.oup.com/ismej/article/17/1/140/7474015 
  - calculate MAGs abundance in a metagenomic dataset/community using RPKM, TPM, the mean raw read coverage of a MAG, and many other metrics. Usually the metrics are calculated in CheckM, MetaWRAP, CoverM
  - escribes GCPM (genome copies per million reads) calculation based on TPM as it is implemented in MetaWRAP software
  - MetaWRAP github page and noticed that "quant_bins" - module that calculates GCPM - have attracted some critique, which left without an answer from the creator

- [reddit bioinfrmatis](https://www.reddit.com/r/bioinformatics/comments/1e8nptd/metrics_you_use_in_your_metagenomemags_analysis/?sort=top)
  - Relative abundance is tricky because I think what researchers want to say is what fraction of the (prokaryotic) cells of community belong to a particular population. Yet we can’t really do that with a metagenome alone — not without sufficient metadata or spike-in standards.

- [dereplicate MAGs? (metagenome assembly genomes)](https://www.reddit.com/r/bioinformatics/comments/or0r6z/how_to_dereplicate_mags_metagenome_assembly/?sort=top)
  - ou should look at https://github.com/MrOlm/drep . Thats exactly the tool you need. Usually one takes all their bins and dereplicates them at 99% ANI for strain level dereplication or 95% at species level. For preserving the best quality, you would need to check yourself if the best genome survived the dereplication afaik. You probably want some sort of quality score and chose the one with the highest score out of the bins that got grouped as one by dereplication.

## Adquisición de Datos Ocurrencia

```{r}
#| label: data-acquisition-summary

if (exists("pipeline_report") && !is.null(pipeline_report)) {
  data_summary <- pipeline_report$data_acquisition
  
  kable(
    data.frame(
      Fuente = c("OBIS", "GBIF", "Combinados", "Limpios"),
      Registros = c(
        data_summary$obis_records,
        data_summary$gbif_records, 
        data_summary$combined_records,
        data_summary$cleaned_records
      )
    ),
    caption = "Resumen de adquisición de datos de ocurrencia",
    format = "html"
  ) 
  # |>
  # kable_styling(bootstrap_options = c("striped", "hover", "condensed"))
}
```

El pipeline integra datos de dos fuentes principales:

- **OBIS (Ocean Biodiversity Information System)**: Base de datos especializada en biodiversidad marina
- **GBIF (Global Biodiversity Information Facility)**: Repositorio global de datos de biodiversidad

## Integration with occurrence data

Link genomic data with the spatial occurrence data you already have

### Limpieza y Validación de Datos

Utilizamos el paquete `CoordinateCleaner` para implementar un protocolo de limpieza comprehensivo:

```{r}
#| label: data-quality-metrics

if (exists("cleaned_occurrences") && !is.null(cleaned_occurrences) && nrow(cleaned_occurrences) > 0) {
  
  # Calcular métricas de calidad
  quality_metrics <- data.frame(
    Métrica = c(
      "Completitud de coordenadas",
      "Completitud taxonómica", 
      "Completitud temporal",
      "Registros con profundidad"
    ),
    Porcentaje = c(
      round(sum(!is.na(cleaned_occurrences$decimalLatitude) & 
                !is.na(cleaned_occurrences$decimalLongitude)) / nrow(cleaned_occurrences) * 100, 1),
      round(sum(!is.na(cleaned_occurrences$scientificName)) / nrow(cleaned_occurrences) * 100, 1),
      round(sum(!is.na(cleaned_occurrences$year)) / nrow(cleaned_occurrences) * 100, 1),
      round(sum(!is.na(cleaned_occurrences$depth) & cleaned_occurrences$depth > 0, na.rm = TRUE) / nrow(cleaned_occurrences) * 100, 1)
    )
  )
  
  kable(
    quality_metrics,
    caption = "Métricas de calidad de datos después de la limpieza",
    format = "html"
  ) 
  # |>
  # kable_styling(bootstrap_options = c("striped", "hover"))
}
```

# Resultados

## Control del proyecto con Nix

El ambiente (software, dependencias del sistema, librerías, etc.) se controla con el archivo '[build_env.R](https://github.com/santi-rios/NereidaPipeline/blob/main/build_env.R)'. el cuál facilita la ejecución de distintas tareas controladas por los scripts del directorio '[scripts/](https://github.com/santi-rios/NereidaPipeline/tree/main/scripts/)'

## Control de Pipeline con targets

La pipline es controlada con el archivo '[_targets.R](https://github.com/santi-rios/NereidaPipeline/blob/main/_targets.R)', el cual controla el flujo utilizando diversas funciones escritas en el direcotio '[R/](https://github.com/santi-rios/NereidaPipeline/tree/main/R)':

- '[R/data_acquisition.R](https://github.com/santi-rios/NereidaPipeline/blob/main/R/data_acquisition.R)': Integrating OBIS, GBIF, biomaRt, wikitaxa, and PRISM for comprehensive data collection.
- '[R/data_cleaning.R](https://github.com/santi-rios/NereidaPipeline/blob/main/R/data_cleaning.R)': Standardizing and validating marine occurrence records from biological collection databases.
- '[R/data_visualization.R](https://github.com/santi-rios/NereidaPipeline/blob/main/R/data_visualization.R)'
- '[R/database_integration.R](https://github.com/santi-rios/NereidaPipeline/blob/main/R/database_integration.R)': Efficient storage and querying of heterogeneous marine biodiversity data.
- '[R/evolutionary_analysis.R](https://github.com/santi-rios/NereidaPipeline/blob/main/R/evolutionary_analysis.R)': phylostratigraphic analysis and evolutionary studies in marine organisms.
- '[R/geospatial_processing.R](https://github.com/santi-rios/NereidaPipeline/blob/main/R/geospatial_processing.R)': For handling marine occurrence data with spatial coordinates and environmental layers.
- '[R/metagenomic_analysis.R](https://github.com/santi-rios/NereidaPipeline/blob/main/R/metagenomic_analysis.R)'
- '[R/taxonomic_management.R](https://github.com/santi-rios/NereidaPipeline/blob/main/R/taxonomic_management.R)': standardized handling of marine biodiversity taxonomic information.

## Sujetos Experimentales

```{r}
#| label: executive-summary
#| results: asis

if (safe_check("pipeline_report")) {
  cat("**Especies analizadas:** ", length(pipeline_report$species_analyzed), "\n\n")
  cat("**Registros procesados:** ", pipeline_report$data_acquisition$cleaned_records, "\n\n")
  cat("**Estado del pipeline:** ", pipeline_report$pipeline_status, "\n\n")
  cat("**Fecha de análisis:** ", format(pipeline_report$pipeline_completion_date, "%d/%m/%Y"), "\n\n")
} else {
  cat("⚠️ **Pipeline en progreso o no completado**\n\n")
  cat("Para generar este reporte completo, primero ejecuta:\n\n")
  cat("```r\n")
  cat("library(targets)\n")
  cat("tar_make()\n")
  cat("```\n\n")
}
```

Species Analyzed

```{r species-list}
species_list <- c(
  "Acropora cervicornis",
  "Acropora palmata",
  "Porites astreoides"
)

kable(data.frame(
  "Species" = species_list,
  "Common Name" = c("Staghorn Coral", "Elkhorn Coral", "Mustard Hill Coral")
), caption = "Target Species for Genomic Analysis") %>%
  kable_styling(bootstrap_options = c("striped", "hover"))
```



## Datos disponibles

```{r}
#| label: data-overview

# Create overview of available data
data_overview <- data.frame(
  Objeto = names(loaded_targets),
  Disponible = sapply(loaded_targets, function(x) if(x) "Sí" else "No"),
  Tipo = sapply(names(loaded_targets), function(name) {
    if (loaded_targets[[name]] && exists(name)) {
      obj <- get(name)
      if (is.data.frame(obj)) {
        paste("data.frame (", nrow(obj), " filas)")
      } else if (is.list(obj)) {
        paste("lista (", length(obj), " elementos)")
      } else {
        class(obj)[1]
      }
    } else {
      "No disponible"
    }
  })
)

kable(
  data_overview,
  caption = "Resumen de objetos del pipeline",
  format = "html"
) 
# |>
#   kable_styling(bootstrap_options = c("striped", "hover"))
```


### Datos Ómicos

Se encontraron estas especies en las bases de datos 

<!-- TODO: poner automáticamente las bases de datos) -->

```{r availability-summary}
if (!is.null(genome_availability)) {
  avail_summary <- genome_availability %>%
    group_by(species, database) %>%
    summarise(
      assemblies = n(),
      .groups = "drop"
    ) %>%
    tidyr::pivot_wider(
      names_from = database,
      values_from = assemblies,
      values_fill = 0
    )
  
  kable(avail_summary, 
        caption = "Number of genome assemblies found in each database") %>%
    kable_styling(bootstrap_options = c("striped", "hover", "condensed"))
} else {
  cat("No availability data available.\n")
}
```

Detailed Assembly Information

```{r detailed-availability}
if (!is.null(genome_availability)) {
  genome_availability %>%
    select(species, database, organism_name, assembly_accession, 
           bioproject, biosample, seq_rel_date) %>%
    kable(caption = "Detailed genome assembly information") %>%
    kable_styling(
      bootstrap_options = c("striped", "hover", "condensed"),
      font_size = 10
    ) %>%
    scroll_box(width = "100%", height = "400px")
}
```

#### Resumen por especies y tipo de datos

Data Completeness Visualization

```{r completeness-viz, fig.width=10, fig.height=6}
if (!is.null(genomic_quality)) {
  # Reshape data for plotting
  plot_data <- genomic_quality %>%
    tidyr::pivot_longer(
      cols = c(proteome_available, cds_available, gff_available),
      names_to = "data_type",
      values_to = "available"
    ) %>%
    mutate(
      data_type = gsub("_available", "", data_type),
      data_type = tools::toTitleCase(data_type)
    )
  
  ggplot(plot_data, aes(x = species, y = data_type, fill = available)) +
    geom_tile(color = "white", size = 1) +
    scale_fill_manual(
      values = c("TRUE" = "#2ecc71", "FALSE" = "#e74c3c"),
      labels = c("TRUE" = "Available", "FALSE" = "Not Available")
    ) +
    labs(
      title = "Genomic Data Retrieval Status",
      subtitle = "Data types retrieved for each species",
      x = "Species",
      y = "Data Type",
      fill = "Status"
    ) +
    theme_minimal() +
    theme(
      axis.text.x = element_text(angle = 45, hjust = 1, size = 11),
      axis.text.y = element_text(size = 11),
      plot.title = element_text(face = "bold", size = 16),
      plot.subtitle = element_text(size = 12),
      legend.position = "bottom"
    )
}
```

#### Data Size Statistics

```{r data-sizes}
if (!is.null(genomic_quality)) {
  size_data <- genomic_quality %>%
    filter(!is.na(proteome_size)) %>%
    select(species, proteome_size, cds_count)
  
  if (nrow(size_data) > 0) {
    kable(size_data,
          col.names = c("Species", "Proteome Size (MB)", "CDS Count"),
          caption = "Downloaded data statistics",
          digits = 2) %>%
      kable_styling(bootstrap_options = c("striped", "hover"))
  }
}
```

#### Successfully Retrieved Data

```{r successful-retrievals}
if (!is.null(genomic_sequences)) {
  successful <- data.frame(
    species = character(),
    database = character(),
    data_type = character(),
    file_path = character(),
    stringsAsFactors = FALSE
  )
  
  for (sp_name in names(genomic_sequences)) {
    if (sp_name == "availability" || sp_name == "retrieval_date" || 
        sp_name == "database") next
    
    sp_data <- genomic_sequences[[sp_name]]
    
    for (dtype in c("proteome", "cds", "gff")) {
      if (!is.null(sp_data[[dtype]]) && sp_data[[dtype]]$status == "success") {
        successful <- rbind(successful, data.frame(
          species = sp_name,
          database = sp_data$database_used,
          data_type = dtype,
          file_path = basename(sp_data[[dtype]]$file),
          stringsAsFactors = FALSE
        ))
      }
    }
  }
  
  if (nrow(successful) > 0) {
    kable(successful,
          caption = "Successfully retrieved genomic data files") %>%
      kable_styling(bootstrap_options = c("striped", "hover")) %>%
      column_spec(3, bold = TRUE, color = "#27ae60")
  } else {
    cat("No data successfully retrieved.\n")
  }
}
```

#### Data Not Found

```{r failed-retrievals}
if (!is.null(genomic_sequences)) {
  failed <- data.frame(
    species = character(),
    data_type = character(),
    reason = character(),
    stringsAsFactors = FALSE
  )
  
  for (sp_name in names(genomic_sequences)) {
    if (sp_name == "availability" || sp_name == "retrieval_date" || 
        sp_name == "database") next
    
    sp_data <- genomic_sequences[[sp_name]]
    
    # Check if species was not available at all
    if (!is.null(sp_data$status) && sp_data$status == "not_available") {
      failed <- rbind(failed, data.frame(
        species = sp_name,
        data_type = "All",
        reason = "Species not found in any database",
        stringsAsFactors = FALSE
      ))
      next
    }
    
    for (dtype in c("proteome", "cds", "gff")) {
      if (!is.null(sp_data[[dtype]]) && sp_data[[dtype]]$status == "error") {
        failed <- rbind(failed, data.frame(
          species = sp_name,
          data_type = dtype,
          reason = sp_data[[dtype]]$message,
          stringsAsFactors = FALSE
        ))
      }
    }
  }
  
  if (nrow(failed) > 0) {
    kable(failed,
          caption = "Data retrieval failures") %>%
      kable_styling(bootstrap_options = c("striped", "hover")) %>%
      column_spec(2, color = "#e74c3c")
  } else {
    cat("✓ All requested data successfully retrieved!\n")
  }
}
```


## Análisis de Datos de Ocurrencia

```{r}
#| label: occurrence-analysis

if (safe_check("cleaned_occurrences")) {
  
  # Basic summary
  cat("### Resumen de Datos Limpios\n\n")
  cat("- **Total de registros:** ", nrow(cleaned_occurrences), "\n")
  cat("- **Especies únicas:** ", length(unique(cleaned_occurrences$scientificName)), "\n")
  cat("- **Rango temporal:** ", min(cleaned_occurrences$year, na.rm = TRUE), "-", 
      max(cleaned_occurrences$year, na.rm = TRUE), "\n\n")
  
  # Species summary
  species_summary <- cleaned_occurrences |>
    group_by(scientificName) |>
    summarise(
      Registros = n(),
      `Años únicos` = length(unique(year[!is.na(year)])),
      `Lat mín` = round(min(decimalLatitude, na.rm = TRUE), 2),
      `Lat máx` = round(max(decimalLatitude, na.rm = TRUE), 2),
      `Lon mín` = round(min(decimalLongitude, na.rm = TRUE), 2),
      `Lon máx` = round(max(decimalLongitude, na.rm = TRUE), 2),
      .groups = "drop"
    )
  
  kable(
    species_summary,
    caption = "Resumen por especie",
    format = "html"
  ) 
  # |>
  #   kable_styling(bootstrap_options = c("striped", "hover", "condensed"))
  
} else {
  cat("⚠️ Datos de ocurrencia no disponibles. Ejecuta el pipeline primero.\n")
}
```


Summary by Species and Data Type

```{r retrieval-summary}
if (!is.null(genomic_quality)) {
  kable(genomic_quality, 
        caption = "Genomic data retrieval summary",
        digits = 2) %>%
    kable_styling(bootstrap_options = c("striped", "hover")) %>%
    column_spec(2, bold = TRUE) %>%
    column_spec(3, color = ifelse(genomic_quality$data_completeness == 100, 
                                   "green", "orange"))
}
```


## Distribución Espacial de Especies

```{r}
#| label: species-distribution
#| fig-cap: "Distribución espacial de registros de ocurrencia por especie"

if (exists("cleaned_occurrences") && !is.null(cleaned_occurrences) && nrow(cleaned_occurrences) > 0) {
  
  # Filtrar coordenadas válidas
  valid_coords <- cleaned_occurrences |>
    filter(
      !is.na(decimalLatitude), 
      !is.na(decimalLongitude),
      !is.na(scientificName),
      decimalLatitude >= -90, decimalLatitude <= 90,
      decimalLongitude >= -180, decimalLongitude <= 180
    )
  
  if (nrow(valid_coords) > 0) {
    # Crear mapa interactivo
    species_colors <- c("#E31A1C", "#1F78B4", "#33A02C", "#FF7F00", "#6A3D9A")
    species_list <- unique(valid_coords$scientificName)
    
    m <- leaflet(valid_coords) |>
      addProviderTiles(providers$CartoDB.Positron) |>
      setView(
        lng = mean(valid_coords$decimalLongitude), 
        lat = mean(valid_coords$decimalLatitude), 
        zoom = 6
      )
    
    # Añadir puntos por especie
    for (i in seq_along(species_list)) {
      species_data <- valid_coords |> filter(scientificName == species_list[i])
      
      m <- m |>
        addCircleMarkers(
          data = species_data,
          lng = ~decimalLongitude,
          lat = ~decimalLatitude,
          color = species_colors[i],
          radius = 3,
          stroke = FALSE,
          fillOpacity = 0.7,
          group = species_list[i],
          popup = ~paste0(
            "<b>Especie:</b> ", scientificName, "<br>",
            "<b>Fuente:</b> ", data_source, "<br>",
            "<b>Año:</b> ", year
          )
        )
    }
    
    # Añadir control de capas
    m <- m |>
      addLayersControl(
        overlayGroups = species_list,
        options = layersControlOptions(collapsed = FALSE)
      )
    
    m
  }
}
```

## Análisis de Idoneidad de Hábitat

```{r}
#| label: fig-habitat-suitability
#| fig-cap: "Mapa de idoneidad de hábitat para las especies analizadas"

if (exists("habitat_models") && !is.null(habitat_models) && length(habitat_models) > 0) {
  
  # Crear visualización de idoneidad por especies usando solo datos serializables
  species_with_models <- names(habitat_models)[!sapply(habitat_models, is.null)]
  
  if (length(species_with_models) > 0) {
    
    # Crear gráfico de barras usando información del modelo sin acceder a SpatRaster
    suitability_data <- purrr::map_dfr(species_with_models, function(species) {
      model <- habitat_models[[species]]
      
      # Verificar que el modelo existe y tiene datos del modelo
      if (!is.null(model) && !is.null(model$model_data)) {
        
        # Calcular estadísticas básicas del modelo sin acceder a predicciones raster
        presence_points <- sum(model$model_data$presence == 1, na.rm = TRUE)
        background_points <- sum(model$model_data$presence == 0, na.rm = TRUE)
        
        # Calcular probabilidades del modelo en los puntos de datos
        if (!is.null(model$model) && inherits(model$model, c("lm", "glm"))) {
          predicted_probs <- predict(model$model, type = "response")
          
          data.frame(
            Especie = gsub("_", " ", species),
            `Puntos de presencia` = presence_points,
            `Puntos de fondo` = background_points,
            `Probabilidad media` = mean(predicted_probs, na.rm = TRUE),
            `Probabilidad máxima` = max(predicted_probs, na.rm = TRUE),
            `AIC del modelo` = AIC(model$model)
          )
        } else {
          # Si no hay modelo válido, usar solo información básica
          data.frame(
            Especie = gsub("_", " ", species),
            `Puntos de presencia` = presence_points,
            `Puntos de fondo` = background_points,
            `Probabilidad media` = NA,
            `Probabilidad máxima` = NA,
            `AIC del modelo` = NA
          )
        }
      } else {
        NULL
      }
    })
    
    if (!is.null(suitability_data) && nrow(suitability_data) > 0) {
      
      # Crear tabla resumen
      kable(
        suitability_data,
        caption = "Resumen de modelos de idoneidad de hábitat por especie",
        format = "html",
        digits = 3
      ) 
      # |>
      # kable_styling(bootstrap_options = c("striped", "hover", "responsive"))
      
      # Crear gráfico de barras para métricas del modelo
      if (any(!is.na(suitability_data$`Probabilidad media`))) {
        
        # Preparar datos para el gráfico
        plot_data <- suitability_data %>%
          select(Especie, `Puntos de presencia`, `Probabilidad media`, `AIC del modelo`) %>%
          pivot_longer(cols = -Especie, names_to = "Métrica", values_to = "Valor") %>%
          filter(!is.na(Valor))
        
        if (nrow(plot_data) > 0) {
          p <- plot_data %>%
            ggplot(aes(x = Especie, y = Valor, fill = Especie)) +
            geom_col(alpha = 0.8) +
            facet_wrap(~Métrica, scales = "free_y", ncol = 2) +
            scale_fill_viridis_d() +
            labs(
              title = "Métricas de Modelos de Idoneidad de Hábitat",
              x = "Especie",
              y = "Valor"
            ) +
            theme_minimal() +
            theme(
              axis.text.x = element_text(angle = 45, hjust = 1),
              legend.position = "none"
            )
          
          print(p)
        }
      }
      
    } else {
      cat("No se pudieron calcular métricas de idoneidad debido a problemas en los datos del modelo.\n")
    }
    
  } else {
    cat("No hay modelos de hábitat disponibles para visualización.\n")
  }
  
} else {
  cat("Los modelos de idoneidad de hábitat no están disponibles.\n")
}
```

## Análisis Espacial Comprehensivo

```{r}
#| label: spatial-analysis-results

if (exists("spatial_analysis") && !is.null(spatial_analysis)) {
  
  # Extraer estadísticas espaciales
  spatial_stats <- spatial_analysis$spatial_statistics
  
  if (!is.null(spatial_stats)) {
    
    # Crear tabla de métricas espaciales
    spatial_metrics <- data.frame(
      Métrica = c(
        "Número de ocurrencias",
        "Rango latitudinal (°)",
        "Rango longitudinal (°)",
        "Centroide latitudinal (°)",
        "Centroide longitudinal (°)",
        "Área de ocupación (km²)",
        "Número de celdas de grilla"
      ),
      Valor = c(
        spatial_stats$n_occurrences,
        round(diff(spatial_stats$lat_range), 2),
        round(diff(spatial_stats$lon_range), 2),
        round(spatial_stats$centroid_lat, 3),
        round(spatial_stats$centroid_lon, 3),
        spatial_stats$area_of_occupancy_km2,
        spatial_stats$n_grid_cells
      )
    )
    
    kable(
      spatial_metrics,
      caption = "Métricas espaciales del análisis de distribución",
      format = "html"
    ) 
    # |>
    # kable_styling(bootstrap_options = c("striped", "hover"))
  }
}
```

## Nicho Ambiental

```{r}
#| label: environmental-niche-analysis
#| fig-cap: "Análisis del nicho ambiental de las especies marinas"

if (exists("spatial_analysis") && !is.null(spatial_analysis$environmental_niche)) {
  
  env_niche <- spatial_analysis$environmental_niche
  
  # Convertir a formato largo para visualización
  niche_data <- purrr::map_dfr(names(env_niche), function(var) {
    var_stats <- env_niche[[var]]
    
    data.frame(
      Variable = case_when(
        var == "depth_m" ~ "Profundidad (m)",
        var == "sst_celsius" ~ "Temperatura (°C)",
        var == "salinity_psu" ~ "Salinidad (PSU)",
        var == "chlorophyll_mg_m3" ~ "Clorofila-a (mg/m³)",
        TRUE ~ var
      ),
      Media = var_stats$mean,
      Desviacion_estandar = var_stats$sd,  # <-- SIN ESPACIOS
      Minimo = var_stats$min,
      Maximo = var_stats$max,
      Mediana = var_stats$median,
      Q25 = var_stats$q25,
      Q75 = var_stats$q75
    )
  })
  
  if (nrow(niche_data) > 0) {
    # Crear nombres más amigables para la tabla
    niche_data_display <- niche_data
    names(niche_data_display) <- c(
      "Variable", "Media", "Desviación estándar", 
      "Mínimo", "Máximo", "Mediana", "Q25", "Q75"
    )
    
    # Tabla de estadísticas
    kable(
      niche_data_display,
      caption = "Preferencias ambientales de las especies analizadas",
      format = "html",
      digits = 2
    ) 
    # |>
    # kable_styling(bootstrap_options = c("striped", "hover", "responsive"))
    
    # Gráfico usando los nombres sin espacios
    niche_long <- niche_data |>
      select(Variable, Media, Desviacion_estandar, Minimo, Maximo, Mediana) |>  # <-- NOMBRES SIN ESPACIOS
      pivot_longer(cols = -Variable, names_to = "Estadistica", values_to = "Valor")
    
    if (nrow(niche_long) > 0) {
      p_niche <- niche_long |>
        filter(Estadistica %in% c("Minimo", "Mediana", "Maximo")) |>  # <-- SIMPLIFICAR
        ggplot(aes(x = Variable, y = Valor, fill = Estadistica)) +
        geom_col(position = "dodge", alpha = 0.8) +
        scale_fill_viridis_d() +
        labs(
          title = "Distribución de Preferencias Ambientales",
          x = "Variable Ambiental",
          y = "Valor",
          fill = "Estadística"
        ) +
        theme_minimal() +
        theme(
          axis.text.x = element_text(angle = 45, hjust = 1),
          legend.position = "bottom"
        ) +
        facet_wrap(~Variable, scales = "free", ncol = 2)
      
      print(p_niche)
    }
    
    cat("\n\n*Nota: Las estadísticas ambientales muestran las condiciones preferidas por las especies en sus hábitats naturales.*\n\n")
  }
  
} else {
  cat("Los datos de nicho ambiental no están disponibles.\n\n")
  cat("Esto puede ocurrir si:\n")
  cat("- El análisis espacial no se completó correctamente\n")
  cat("- No hay suficientes datos ambientales\n")
  cat("- Los objetos SpatRaster no se cargaron correctamente\n\n")
}
```

## Base de Datos Integrada

```{r}
#| label: database-summary

if (exists("data_summaries") && !is.null(data_summaries)) {
  
  # Resumen de la base de datos
  if (!is.null(data_summaries$species)) {
    species_summary <- data_summaries$species
    
    if (nrow(species_summary) > 0) {
      
      # Crear tabla interactiva de especies
      datatable(
        species_summary,
        caption = "Resumen de especies en la base de datos integrada",
        options = list(
          pageLength = 10,
          scrollX = TRUE,
          dom = 'Bfrtip',
          buttons = c('copy', 'csv', 'excel')
        ),
        filter = 'top',
        rownames = FALSE
      ) |>
      formatRound(columns = c('n_records'), digits = 0)
    }
  }
}
```

La base de datos integrada utiliza **DuckDB** como backend NoSQL, permitiendo:

- **Almacenamiento eficiente** de datos heterogéneos (ocurrencias, taxonomía, ambiente)
- **Consultas flexibles** usando sintaxis SQL y JSON
- **Exportación múltiple** a formatos CSV, JSON, y Parquet
- **Escalabilidad** para grandes volúmenes de datos

### Implicaciones para la Conservación

#### Especies Prioritarias

```{r}
#| label: conservation-priorities

if (exists("cleaned_occurrences") && !is.null(cleaned_occurrences) && nrow(cleaned_occurrences) > 0) {
  
  # Análisis de prioridades de conservación CON DATOS TEMPORALES
  conservation_analysis <- cleaned_occurrences |>
    # Conversión simple y segura de year
    mutate(
      year_numeric = as.numeric(year)  # ¡Así de simple!
    ) |>
    group_by(scientificName) |>
    summarise(
      `Registros totales` = n(),
      `Rango geográfico` = round(
        sqrt((max(decimalLatitude, na.rm = TRUE) - min(decimalLatitude, na.rm = TRUE))^2 + 
             (max(decimalLongitude, na.rm = TRUE) - min(decimalLongitude, na.rm = TRUE))^2), 2
      ),
      `Años de registro` = max(year_numeric, na.rm = TRUE) - min(year_numeric, na.rm = TRUE),
      `Año más reciente` = max(year_numeric, na.rm = TRUE),
      `Año más antiguo` = min(year_numeric, na.rm = TRUE),
      `Profundidad media (m)` = round(mean(depth, na.rm = TRUE), 1),
      .groups = "drop"
    ) |>
    mutate(
      `Prioridad conservación` = case_when(
        `Registros totales` < 50 & `Rango geográfico` < 2 ~ "ALTA",
        `Registros totales` < 100 & `Rango geográfico` < 5 ~ "MEDIA",
        `Año más reciente` < 2015 & `Registros totales` < 200 ~ "MEDIA",  # Especies sin registros recientes
        TRUE ~ "BAJA"
      )
    ) |>
    arrange(desc(`Prioridad conservación`), desc(`Año más reciente`))
  
  # Mostrar la tabla
  if (nrow(conservation_analysis) > 0) {
    kable(
      conservation_analysis,
      caption = "Análisis de prioridades de conservación basado en datos de ocurrencia",
      format = "html"
    )
    
    # Agregar análisis temporal adicional
    cat("\n\n### Análisis Temporal\n\n")
    
    temporal_summary <- cleaned_occurrences |>
      mutate(year_numeric = as.numeric(year)) |>
      summarise(
        `Período de estudio` = paste(min(year_numeric, na.rm = TRUE), "-", max(year_numeric, na.rm = TRUE)),
        `Años con datos` = length(unique(year_numeric)),
        `Registros por década` = paste(
          "1970s:", sum(year_numeric >= 1970 & year_numeric < 1980, na.rm = TRUE), "|",
          "1980s:", sum(year_numeric >= 1980 & year_numeric < 1990, na.rm = TRUE), "|", 
          "1990s:", sum(year_numeric >= 1990 & year_numeric < 2000, na.rm = TRUE), "|",
          "2000s:", sum(year_numeric >= 2000 & year_numeric < 2010, na.rm = TRUE), "|",
          "2010s:", sum(year_numeric >= 2010 & year_numeric < 2020, na.rm = TRUE), "|",
          "2020s:", sum(year_numeric >= 2020, na.rm = TRUE)
        )
      )
    
    cat("**Resumen temporal del dataset:**\n\n")
    cat("- Período:", temporal_summary$`Período de estudio`, "\n")
    cat("- Años únicos con datos:", temporal_summary$`Años con datos`, "\n") 
    cat("- Distribución por décadas:", temporal_summary$`Registros por década`, "\n\n")
    
  } else {
    cat("No se pudieron calcular las prioridades de conservación debido a problemas en los datos.\n")
  }
  
} else {
  cat("⚠️ Datos de ocurrencia no disponibles para análisis de conservación.\n")
}
```


## Manejo de git

Gracias a la integración de los flujos de trabajo (*workflows*) de github (controlados por los archivos en el directorio '[.github/workflows](https://github.com/santi-rios/NereidaPipeline/tree/main/.github/workflows)'), se autamitza y simplifica el flujo de trabajo.

The workflows directory contains GitHub Actions workflows that automate tasks when you push your code to GitHub.

Example:

ci.yml (Continuous Integration)

- This file likely defines an automated process that runs whenever you push code or create a pull request.
- Checks that your code builds correctly
- Runs any tests you've defined
- Validates that your R packages can be installed
- May check code style/quality

::: {.callout-note  title="Detalles téxnicos de workflows"}

What happens when you push to GitHub?
Once these files are in your repository:

GitHub automatically recognizes and activates these workflows
They'll run according to their defined triggers (e.g., on push, schedule, etc.)
You'll see workflow runs in the "Actions" tab of your repository
The workflows execute on GitHub's servers
You'll receive notifications if workflows fail
Any artifacts or outputs will be stored according to the workflow configuration

:::



## Error handling

[@noble2009]: During the development of a complicated set of experiments, you will introduce errors into your code. Such errors are inevitable, but they are particularly problematic if they are difficult to track down or, worse, if you don’t know about them and hence draw invalid conclusions from your experiment. Here are three suggestions for error handling. Write robust code to detect errors.

::: {.callout-note}
'direnv: error /home/santi/Projects/NereidaPipeline/.envrc is blocked. Run `direnv allow` to approve its content'
:::





# Discusión

La implementación de avanzadas herramientas bioinformáticas y la gestión eficiente de pipelines han revolucionado el estudio de la biodiversidad y la evolución de la biota marina. En este marco, el proyecto propone una aplicación de R que hace uso de Nix por medio del paquete R {rix}, convergiendo en una solución óptima para el manejo de diversas funciones, incluyendo el procesamiento de datos, la gestión de código y la integración de información en repositorios.

Gracias al uso de Nix, un sistema de paquetes de código abierto que adopta una nueva manera de manejar las dependencias, proporcionando un entorno de trabajo coherentemente reproducible. Asegura que los paquetes se construyen e instalan de manera aislada, lo que permite un control de versiones y una gestión de las dependencias finamente afinada (Dolstra, E., 2006). Así, Nix se impone como una herramienta fundamental cambio de contextos académicos y empresariales, permitiendo la creación de entornos de trabajo estables y reproducibles.

## Control de Pipeline Avanzado

### Orquestación del Flujo de Trabajo con `Make`

El uso de `Make` como un "orquestador" de alto nivel simplifica la interacción y estandariza los procedimientos.

[@noble2009]: Este influyente artículo describe las mejores prácticas para organizar proyectos de biología computacional. Recomienda explícitamente el uso de `Make` para automatizar la pipeline, desde la descarga de datos hasta la generación de figuras finales. Citarlo posiciona su uso de `Makefile` como una práctica establecida y recomendada para mantener la organización, la claridad y la automatización en proyectos complejos, lo cual es vital en estudios integrativos de biodiversidad marina.


::: {.callout-note  title="Makefile"}

Makefile funciona como un "protocolo de laboratorio" ejecutable. Su propósito principal es automatizar y estandarizar las tareas repetitivas, encapsulando comandos complejos en alias simples y declarativos.

Makefile no es solo un archivo, sino la interfaz de control principal. En lugar de recordar una serie de scripts y sus argumentos, usted y sus colaboradores solo necesitan interactuar con comandos semánticos como make test o make regenerate.

Así es como su Makefile dirige el flujo:

    make regenerate: Este es el comando fundamental para la reproducibilidad. No ejecuta rix directamente, sino que delega la tarea al script ./regenerate.sh. Este script, a su vez, invoca su archivo build_env.R, donde la función rix::rix() traduce su lista de paquetes de R y dependencias del sistema en un archivo default.nix. Este es el plano exacto de su ambiente.

    make test: Este comando invoca ./test_environment.sh, un paso de validación crucial. El script verifica que el ambiente de Nix, una vez construido, contenga todos los paquetes que su pipeline de {targets} declara necesitar en _targets.R. Esto cierra el círculo, asegurando que el ambiente definido coincide con el ambiente requerido.

    make update: Actúa como un meta-comando que ejecuta una secuencia lógica de tareas a través del script update_workflow.sh, probablemente combinando la regeneración y la prueba del ambiente.

    make clean: Mantiene la higiene del proyecto, eliminando artefactos y resultados intermedios para garantizar que la próxima ejecución comience desde un estado conocido y limpio.

validación crucial. El script verifica que el ambiente de Nix, una vez construido, contenga todos los paquetes que su pipeline de {targets} declara necesitar en _targets.R. Esto cierra el círculo, asegurando que el ambiente definido coincide con el ambiente requerido.

    make update: Actúa como un meta-comando que ejecuta una secuencia lógica de tareas a través del script update_workflow.sh, probablemente combinando la regeneración y la prueba del ambiente.

    make clean: Mantiene la higiene del proyecto, eliminando artefactos y resultados intermedios para garantizar que la próxima ejecución comience desde un estado conocido y limpio.

:::

### Control de versiones automatizado con workflows

#### Aggregation subsystem

[@boyle2009]: **aggregation subsystem*: One of the aims of the computing advances over the last few years has involved the concept of run time aggregation. This approach is epitomized by the semantic web, where people can mash information from a variety of data sources into a single graph. When an analysis run has finished, the observing aggregation system can trigger an indexing operation on the results. The indexing is controlled using the properties that are associated with the output of the analysis run (typically the properties related to the rows or columns that are to be indexed).

> For this last point... we could try a quarto dashboard to summirize the data and make the github actions trigger to continuously (or at query) deploys updated info to the web.

::: {.callout-note}

Razones clave para preferir Nix + rix en proyectos científicos y pipelines

- Reproducibilidad completa: Nix describe exactamente qué se construye y cuáles binarios y bibliotecas del sistema se usan; rix adapta este enfoque al ecosistema R, permitiendo reconstrucciones idénticas en diferentes máquinas y CI.
- Gestión unificada de R y dependencias del sistema: muchas herramientas R necesitan bibliotecas C/Fortran. Nix las gestiona junto con los paquetes R, evitando fallos invisibles por falta de libs nativas.
- Declaratividad, versionado y trazabilidad: los archivos Nix (o los artefactos que genera rix) son documentos versionables que sirven como metadatos exactos del entorno utilizado para un análisis — esencial para reproducibilidad y revisión académica.
- Aislamiento hermético: elimina efectos de entornos previos o variaciones en el usuario, reduciendo errores “works on machine X”.
- Integración con CI y archivado a largo plazo: cachés binarios y la capacidad de reconstruir entornos permiten validar pipelines en CI y archivar entornos reproducibles junto a publicaciones.
- Interoperabilidad: aunque renv y conda pueden usarse junto a Nix, emplear Nix como capa superior unifica la gestión y reduce la complejidad operativa.

Limitaciones y balance práctico

- Curva de aprendizaje: Nix requiere tiempo para dominar sus conceptos. rix reduce fricción para usuarios R, pero la adopción institucional puede exigir formación.
- Uso de disco y recursos: la store de Nix puede ocupar más espacio, aunque la deduplicación y caché binario compensa en entornos compartidos.
- Windows: Nix funciona mejor en Linux/macOS; en Windows suele requerir WSL o contenedores (esto está mejorando con la comunidad).

Recomendaciones prácticas

- Para investigación reproducible, producción de pipelines y CI: adoptar Nix + rix como estándar de entorno. Mantener la expresión Nix en el repositorio junto con el código y los datos procesables.
- Para desarrollo rápido o enseñanza: combinar renv (para control fino de paquetes R durante el desarrollo) dentro de un entorno Nix que garantice las dependencias del sistema. renv puede convivir con Nix: renv controla versiones R; Nix asegura libs nativas.
- Para entornos multi-lenguaje con uso intensivo de paquetes binarios (Python + R + herramientas C): Nix ofrece la solución más coherente y reproducible frente a la mezcla de conda + gestores del sistema.

:::


#### Base de datos con git-lfs

Using Git LFS (Large File Storage) for a DuckDB file is a viable option if the file is large and frequently modified, and if you require version control for its changes.
Reasons to consider Git LFS for DuckDB files:
DuckDB files are often binary: Git is optimized for text-based files and handles binary files inefficiently, especially when they are large and undergo frequent changes.
Version control of large files: Git LFS allows you to track changes to large DuckDB files without bloating the main Git repository. Instead of storing the full file in the repository history for every change, Git LFS stores pointers to the file and manages the actual file content on a separate LFS server.
Faster cloning and fetching: When using Git LFS, only the pointers are downloaded during cloning and fetching, significantly reducing the time and bandwidth required compared to downloading the entire history of large binary files.
Reduced repository size: The main Git repository remains smaller and more manageable, as the large DuckDB file content is stored externally.

PERSPECTIVAS DE GIT-LFS

Considerations and alternatives:
LFS server setup: You need a Git LFS server to store the actual file content. This is often provided by platforms like GitHub, GitLab, or Bitbucket, but you may need to manage your own if using a self-hosted Git solution.
Quota limitations: Cloud-based Git LFS services often have storage and bandwidth quotas, which might be a factor if your DuckDB files are extremely large or frequently accessed by many users.
DVC (Data Version Control): For more complex data management needs, especially in data science and machine learning contexts, DVC offers a more specialized solution for versioning data and models, including large files.
External storage and releases: If your DuckDB files are exceptionally large or not truly part of your codebase's direct version control, consider storing them externally (e.g., cloud storage, shared drives) and linking to them or managing them through release processes.
In summary: If you have large DuckDB files that require version control within your Git repository and are subject to frequent modifications, Git LFS provides an effective way to manage them without the performance and storage overhead of traditional Git. Evaluate your specific needs and consider potential alternatives like DVC for more advanced data versioning requirements.


## Conservación y Evolucón

### Recomendaciones de Manejo

Basándose en los resultados del análisis, se proponen las siguientes estrategias de conservación:

#### 1. **Protección de Hábitats Críticos**
- Establecer áreas marinas protegidas en zonas de alta idoneidad
- Monitorear cambios en las condiciones ambientales clave
- Implementar medidas de mitigación contra el cambio climático

#### 2. **Monitoreo y Vigilancia**
- Desarrollar programas de monitoreo a largo plazo
- Utilizar tecnologías de detección temprana
- Capacitar a comunidades locales en identificación de especies

#### 3. **Restauración Ecológica**
- Identificar áreas históricamente importantes pero actualmente degradadas
- Implementar programas de restauración basados en ciencia
- Evaluar el éxito de las intervenciones de restauración


#### Análisis Evolutivo y Adaptación

```{r}
#| label: evolutionary-insights

# Mostrar insights evolutivos si están disponibles
cat("### Perspectivas Evolutivas\n\n")
cat("El análisis filoestratigráfico revela patrones importantes sobre la evolución y adaptación de las especies marinas:\n\n")

cat("- **Genes antiguos** conservados indican funciones esenciales para la supervivencia marina\n")
cat("- **Genes de origen reciente** pueden representar adaptaciones específicas al ambiente marino\n") 
cat("- **Patrones de expresión** durante el desarrollo sugieren estrategias evolutivas de supervivencia\n\n")

cat("Estas perspectivas son cruciales para:\n\n")
cat("1. **Programas de cría selectiva** para aumentar la resistencia climática\n")
cat("2. **Estrategias de restauración** basadas en diversidad genética\n")
cat("3. **Predicción de respuestas** a cambios ambientales futuros\n\n")
```

## Perspectivas y limitaciones

Potential Applications

- Personalized Medicine: Identifying genetic predispositions to diseases and tailoring treatments based on an individual's genetic makeup. 
- Cancer Research: Identifying mutations in tumors to guide cancer treatment strategies and monitor treatment responses. 
- Infectious Disease: Tracking outbreaks by sequencing pathogens and understanding their genetic relationships. 
- Drug Discovery: Uncovering new drug targets and identifying potential drug repurposing opportunities by understanding disease-causing genetic mechanisms. 

Área de Mejora: La principal fricción a futuro es el acoplamiento manual entre _targets.R y build_env.R. Actualmente, si usted añade library(nuevo_paquete) en su pipeline _targets.R, debe recordar manualmente añadir "nuevo_paquete" al vector targets_packages en build_env.R. A medida que el proyecto crezca y colaboren más personas, es casi seguro que este paso se olvidará, lo que provocará fallos en las pruebas (make test) y frustración.

Para que este flujo de trabajo sea verdaderamente a prueba de futuro, el siguiente paso lógico es automatizar la sincronización de paquetes.

Se podría modificar el script regenerate.sh (o crear uno nuevo) para que, antes de ejecutar build_env.R, primero analice el archivo _targets.R en busca de todas las llamadas library(...). Luego, puede pasar esa lista de paquetes como un argumento a su script de R o escribirla en un archivo temporal que build_env.R pueda leer.

Esto desacoplaría completamente la definición del ambiente de la pipeline, adhiriéndose al principio de "Fuente Única de Verdad" (Single Source of Truth). Su pipeline en _targets.R se convierte en la única fuente que define qué paquetes se necesitan, y el resto del sistema reacciona automáticamente.

Sin embargo, la arquitectura actual es excelente, avanzada y se adelanta a la mayoría de los flujos de trabajo académicos. Es altamente reproducible y fácil de usar. Al implementar la sincronización automática de paquetes, lo convertirá en un sistema prácticamente infalible y listo para escalar a cualquier complejidad.

1. **Sesgos de muestreo**: Los datos de ocurrencia pueden estar sesgados hacia áreas de fácil acceso
2. **Resolución temporal**: La variabilidad interanual y estacional no está completamente capturada
3. **Variables ambientales**: Limitadas a las disponibles en bases de datos globales
4. **Validación de modelos**: Se requiere validación independiente con datos de campo


### Direcciones Futuras

```{r}
#| label: future-directions

future_research <- data.frame(
  `Área de investigación` = c(
    "Integración de datos genómicos",
    "Modelado de cambio climático", 
    "Análisis de conectividad",
    "Monitoreo en tiempo real",
    "Inteligencia artificial"
  ),
  `Descripción` = c(
    "Incorporar datos de secuenciación para análisis poblacionales",
    "Proyectar distribuciones futuras bajo escenarios climáticos",
    "Analizar flujo genético y dispersión larval",
    "Implementar sensores IoT para datos continuos",
    "Desarrollar modelos de aprendizaje automático avanzados"
  ),
  `Prioridad` = c("Alta", "Alta", "Media", "Media", "Baja")
)

kable(
  future_research,
  caption = "Direcciones prioritarias para investigación futura",
  format = "html"
) |>
kable_styling(bootstrap_options = c("striped", "hover", "responsive"))
```


## Conclusiones

El pipeline integrado de análisis de biodiversidad marina ha demostrado ser una herramienta poderosa para:

1. **Integrar múltiples fuentes de datos** de manera eficiente y reproducible
2. **Validar y limpiar datos** usando estándares internacionales
3. **Generar modelos predictivos** de distribución de especies
4. **Identificar prioridades de conservación** basadas en evidencia científica
5. **Proporcionar insights evolutivos** relevantes para la conservación

Los resultados resaltan la importancia de enfoques integrados que combinen datos de ocurrencia, variables ambientales, y análisis evolutivos para informar estrategias efectivas de conservación marina.

✅ Reproducibilidad (Fortaleza Mayor)

Este es el punto más fuerte de su sistema. Al definir el entorno computacional de forma declarativa con rix en build_env.R y materializarlo con Nix, ha eliminado prácticamente la variabilidad del entorno. Cualquier investigador, en cualquier máquina con Nix, puede ejecutar make regenerate y nix-shell para recrear un ambiente de software bit a bit idéntico. Esto es el estándar de oro para la reproducibilidad computacional.

✅ Facilidad de Uso y Mantenimiento (Fortaleza)

El Makefile es la clave aquí. Proporciona una "API" de línea de comandos simple y legible para su proyecto. Un nuevo colaborador no necesita entender los detalles de Nix o los scripts de shell; solo necesita leer la salida de make help para empezar a trabajar. Esto reduce drásticamente la curva de aprendizaje y los posibles errores.

📈 Escalabilidad (Fortaleza con un área de mejora)

    Fortaleza: El uso de {targets} es ideal para la escalabilidad del análisis. Su naturaleza basada en dependencias garantiza que solo se recalculen los pasos necesarios, ahorrando un tiempo de cómputo inmenso a medida que el análisis crece en complejidad.


Nix, utilizado a través de rix, ofrece la solución más sólida y trazable para garantizar entornos reproducibles y pipelines científicos que integran R con dependencias del sistema. Aunque la adopción exige inversión en aprendizaje, los beneficios en reproducibilidad, integridad y archivado hacen de Nix la opción preferente para proyectos científicos serios y para la producción de análisis reproducibles.

ste trabajo usa una estructura estándar para organización de trabajos bioinformáticos [@noble2009]: top-level organization that is logical, with chronological organization at the next level, and logical organization below that. A sample project, called msms, is shown in Figure 1. At the root of most of my projects, I have a data directory for storing fixed data sets, a results directory for tracking computational experiments peformed on that data, a doc directory with one subdirectory per manuscript, and directories such as src for source code and bin for compiled binaries or scripts.

> version control should only be used for files that you edit by hand. Automatically generated files, whether they are compiled programs or the results of a computational experiment, do not belong under version control [@noble2009].


[@boyle2009]: **Layered content management**: To manage data arising from ongoing research experiments we adopted an approach using distributed content repositories. Content repositories allow for the development of a formalized structure that can be associated directly with resources. Easy to adapt. Within a research environment it is generally difficult to hammer down requirements. The requirements change over time, and new functionality is often required at short notice. Easy to understand. Any data management solution will involve a high level of complexity, especially in a distributed research environment. Easy to access. Within a research environment there is little time to be spared for learning (largely transient) informatics systems. • Instrumentation Layer. This layer is used to capture experimental information. The layer models information in a way that makes storage of the information simpler, so that laboratory scientists can easily add and annotate information that is captured from a variety of instruments. • Conceptual Layer. This layer is designed to provide a means to generically interact with the information through the use of high level abstract operations. These operations include the aggregation and retrieval of information, and do not necessitate an understanding of the actual information content. • Organizational Layer. This layer provides a project (or researcher) based view on the information, and therefore is designed to have a "biological focus". Typically the content is organized by factors such as disease, organism or molecule. Each different research, or research group, can individually organize and annotate the data to suit their individual requirements.



### Impacto para la Conservación

- **Identificación de especies vulnerables** con distribuciones restringidas
- **Mapeo de hábitats críticos** que requieren protección prioritaria  
- **Desarrollo de estrategias adaptativas** para el cambio climático
- **Optimización de esfuerzos de monitoreo** y recursos limitados

Este enfoque metodológico puede replicarse para otras regiones y grupos taxonómicos, contribuyendo al conocimiento global sobre biodiversidad marina y su conservación.

::: {.callout  title="💡 Posibles ideas"}

- [ ] : hacer un diccionario compartido con extensiones de vscode.

:::

# Resumen Ejecutivo

## Estado del pipeline

```{r}
#| label: pipeline-status
#| echo: true

# Show pipeline status
cat("Estado de los objetos del pipeline:\n\n")
for (target in names(loaded_targets)) {
  status <- if (loaded_targets[[target]]) "✓ Disponible" else "✗ No disponible"
  cat("-", target, ":", status, "\n")
}

# Check targets status
if (requireNamespace("targets", quietly = TRUE)) {
  cat("\nEstado general del pipeline:\n")
  tar_progress() |>
    count(progress) |>
    kable(col.names = c("Estado", "Número de targets"))
}
```

## Uso recomendado del ambiente y pipeline

***Si se modifica la pipeline***

Al modificar el archivo '[build_env.R](https://github.com/santi-rios/NereidaPipeline/blob/main/build_env.R)' (p. ej. agregar librerías nuevas), ejecutar este comando:

```bash
nix-shell
make update
```

Al ejecutar este script:

- Regeneramos y construimos el ambiente de Nix
- Ejecutamos el script '../test_environment.sh' para comprobar y verificar la disponibilidad de librerías utilizadas en la pipeline
- Ejecutamos la pipeline (*opcional*)

***Si no se agregan nuevos paquetes a la pipeline***

Ejecutar:

```bash
nix-shell
make pipeline
```

<!-- TODO: revisar los scripts y potencialmetne agregar make a los targets individuales, no a toda la pipe -->

# Inspección de la Pipeline

Esta sección documenta la estructura y dependencias de la pipeline de análisis, permitiendo verificar la integridad del flujo de trabajo antes de la ejecución.

## Manifiesto de Targets

El manifiesto muestra todos los targets definidos en la pipeline y sus comandos de ejecución:

```{r}
#| label: pipeline-manifest
#| echo: true
#| code-fold: show

# Mostrar el manifiesto de la pipeline con comandos
tar_manifest(fields = all_of("command")) |>
  kable(
    caption = "Manifiesto completo de la pipeline de análisis",
    format = "html"
  ) |>
  kable_styling(
    bootstrap_options = c("striped", "hover", "condensed"),
    font_size = 10
  ) |>
  scroll_box(width = "100%", height = "500px")
```

## Grafo de Dependencias

El grafo muestra las relaciones entre los diferentes componentes de la pipeline:

```{r}
#| label: pipeline-graph
#| fig-width: 12
#| fig-height: 8
#| fig-cap: "Visualización interactiva de las dependencias de la pipeline"

# Generar visualización interactiva del grafo de dependencias
tar_visnetwork(
  targets_only = TRUE,
  label = c("time", "size", "branches"),
  level_separation = 150,
  degree_from = 1,
  degree_to = 1
)
```

::: {.callout-note}
## Interpretación del Grafo

- **Nodos verdes**: Targets actualizados y sin cambios
- **Nodos azules**: Targets desactualizados que necesitan re-ejecución
- **Nodos grises**: Targets que aún no se han ejecutado
- **Flechas**: Indican dependencias entre targets

El flujo natural va de izquierda a derecha, mostrando cómo los datos se transforman desde la adquisición hasta los resultados finales.
:::

## Resumen de Targets por Fase

```{r}
#| label: targets-by-phase

# Obtener metadata de todos los targets
tar_meta <- tar_meta(fields = c("name", "type", "bytes", "seconds"))

# Clasificar targets por fase del análisis
target_phases <- data.frame(
  Target = tar_meta$name,
  Tipo = tar_meta$type,
  Tamaño = ifelse(!is.na(tar_meta$bytes), 
                  paste(round(tar_meta$bytes / 1024^2, 2), "MB"),
                  "N/A"),
  Tiempo = ifelse(!is.na(tar_meta$seconds),
                  paste(round(tar_meta$seconds, 2), "s"),
                  "N/A"),
  Fase = case_when(
    grepl("obis|gbif|genome|taxonomic", tar_meta$name) ~ "1. Adquisición de Datos",
    grepl("cleaned|combined", tar_meta$name) ~ "2. Limpieza de Datos",
    grepl("environmental|spatial", tar_meta$name) ~ "3. Análisis Espacial",
    grepl("habitat|model", tar_meta$name) ~ "4. Modelado",
    grepl("database|marine_db", tar_meta$name) ~ "5. Integración de Base de Datos",
    grepl("summary|report|export", tar_meta$name) ~ "6. Reportes y Exportación",
    grepl("metagenomic|phylostrat|assembly", tar_meta$name) ~ "7. Análisis Metagenómico",
    TRUE ~ "Otros"
  )
) |>
  arrange(Fase, Target)

# Mostrar tabla por fase
kable(
  target_phases,
  caption = "Targets organizados por fase del análisis",
  format = "html"
) |>
  kable_styling(bootstrap_options = c("striped", "hover", "condensed")) |>
  column_spec(5, bold = TRUE) |>
  scroll_box(width = "100%", height = "600px")
```

## Estadísticas de Ejecución

```{r}
#| label: execution-stats

# Obtener estadísticas de progreso
progress_data <- tar_progress()

if (!is.null(progress_data) && nrow(progress_data) > 0) {
  
  # Resumen por estado
  progress_summary <- progress_data |>
    count(progress) |>
    mutate(
      Porcentaje = round(n / sum(n) * 100, 1),
      Estado = case_when(
        progress == "built" ~ "✓ Completado",
        progress == "skipped" ~ "⊙ Omitido (sin cambios)",
        progress == "started" ~ "⟳ En progreso",
        progress == "errored" ~ "✗ Error",
        TRUE ~ progress
      )
    ) |>
    select(Estado, Cantidad = n, Porcentaje)
  
  kable(
    progress_summary,
    caption = "Estado de ejecución de los targets",
    format = "html"
  ) |>
    kable_styling(bootstrap_options = c("striped", "hover"))
  
  # Visualización de estado
  if (nrow(progress_summary) > 0) {
    ggplot(progress_summary, aes(x = "", y = Cantidad, fill = Estado)) +
      geom_bar(stat = "identity", width = 1) +
      coord_polar("y", start = 0) +
      scale_fill_manual(
        values = c(
          "✓ Completado" = "#27ae60",
          "⊙ Omitido (sin cambios)" = "#3498db", 
          "⟳ En progreso" = "#f39c12",
          "✗ Error" = "#e74c3c"
        )
      ) +
      theme_void() +
      labs(
        title = "Distribución del Estado de Targets",
        fill = "Estado"
      ) +
      theme(
        plot.title = element_text(hjust = 0.5, size = 14, face = "bold"),
        legend.position = "right"
      )
  }
  
} else {
  cat("⚠️ No hay datos de progreso disponibles. Ejecuta `tar_make()` primero.\n")
}
```

## Análisis de Dependencias

```{r}
#| label: dependency-analysis

# Analizar la red de dependencias
deps <- tar_network(targets_only = TRUE)

if (!is.null(deps) && nrow(deps$edges) > 0) {
  
  # Calcular métricas de red
  dependency_metrics <- data.frame(
    Métrica = c(
      "Total de targets",
      "Total de dependencias",
      "Targets raíz (sin dependencias entrantes)",
      "Targets finales (sin dependencias salientes)",
      "Profundidad máxima de la pipeline"
    ),
    Valor = c(
      length(unique(c(deps$edges$from, deps$edges$to))),
      nrow(deps$edges),
      sum(!unique(deps$edges$to) %in% deps$edges$from),
      sum(!unique(deps$edges$from) %in% deps$edges$to),
      "Calcular manualmente"  # Esto requeriría análisis de grafo más complejo
    )
  )
  
  kable(
    dependency_metrics,
    caption = "Métricas de la red de dependencias",
    format = "html"
  ) |>
    kable_styling(bootstrap_options = c("striped", "hover"))
  
  # Targets más conectados
  most_connected <- deps$edges |>
    count(from, sort = TRUE) |>
    head(10) |>
    rename(Target = from, `Dependencias salientes` = n)
  
  kable(
    most_connected,
    caption = "Top 10 targets con más dependencias",
    format = "html"
  ) |>
    kable_styling(bootstrap_options = c("striped", "hover"))
}
```

::: {.callout-tip}
## Uso Práctico

Para verificar la pipeline antes de ejecutarla:

1. **Revisar el manifiesto**: Asegúrate de que todos los comandos sean correctos
2. **Inspeccionar el grafo**: Verifica que las dependencias sean lógicas
3. **Validar sin ejecutar**: Usa `tar_validate()` para detectar errores sin correr la pipeline
4. **Ejecución incremental**: `targets` solo re-ejecuta lo necesario

```r
# Validar la pipeline sin ejecutar
tar_validate()

# Ver qué targets están desactualizados
tar_outdated()

# Ejecutar solo un target específico
tar_make(names = "cleaned_occurrences")
```
:::

## Validación de la Pipeline

```{r}
#| label: pipeline-validation
#| echo: true

# Validar la estructura de la pipeline
validation_result <- tryCatch({
  tar_validate()
  "✓ Pipeline válida - sin errores detectados"
}, error = function(e) {
  paste("✗ Errores detectados:", e$message)
})

cat(validation_result, "\n")
```

## Targets Desactualizados

```{r}
#| label: outdated-targets

# Identificar targets que necesitan actualización
outdated <- tar_outdated()

if (length(outdated) > 0) {
  cat("⚠️ Los siguientes targets necesitan actualización:\n\n")
  for (target in outdated) {
    cat("-", target, "\n")
  }
  cat("\nEjecuta `tar_make()` para actualizar estos targets.\n")
} else {
  cat("✓ Todos los targets están actualizados.\n")
}
```

# Referencias

*Las referencias bibliográficas se incluirían aquí en un análisis completo, citando las fuentes de datos, métodos estadísticos, y literatura científica relevante.*

## Software Citations

Please cite the following software packages used in this analysis:

### biomartr

> Drost HG, Paszkowski J. Biomartr: genomic data retrieval with R. 
> Bioinformatics (2017) 33(8): 1216-1217. 
> doi:10.1093/bioinformatics/btw821

### targets

> Landau, W. M., (2021). The targets R package: a dynamic Make-like 
> function-oriented pipeline toolkit for reproducibility and 
> high-performance computing. Journal of Open Source Software, 6(57), 2959,
> https://doi.org/10.21105/joss.02959

### Biostrings

> Pagès H, Aboyoun P, Gentleman R, DebRoy S (2023). Biostrings: Efficient 
> manipulation of biological strings. R package version 2.68.0,
> https://bioconductor.org/packages/Biostrings.

#### Data Sources

```{r data-sources}
if (!is.null(genomic_sequences)) {
  databases_used <- unique(unlist(lapply(genomic_sequences, function(x) {
    if (is.list(x) && !is.null(x$database_used)) {
      return(x$database_used)
    }
    return(NULL)
  })))
  
  databases_used <- databases_used[!is.null(databases_used)]
  
  if (length(databases_used) > 0) {
    cat("Data retrieved from the following NCBI databases:\n\n")
    for (db in databases_used) {
      if (db == "refseq") {
        cat("- **NCBI RefSeq**: https://www.ncbi.nlm.nih.gov/refseq/\n")
        cat("  > O'Leary NA, et al. Reference sequence (RefSeq) database at NCBI: current status, taxonomic expansion, and functional annotation. Nucleic Acids Res. 2016;44(D1):D733-45.\n\n")
      } else if (db == "genbank") {
        cat("- **NCBI GenBank**: https://www.ncbi.nlm.nih.gov/genbank/\n")
        cat("  > Sayers EW, et al. Database resources of the National Center for Biotechnology Information. Nucleic Acids Res. 2022;50(D1):D20-D26.\n\n")
      }
    }
  }
}
```


## File Locations

All downloaded genomic data files are stored in:

- **Proteomes**: `data/raw/genomic/proteomes/`
- **CDS**: `data/raw/genomic/cds/`
- **GFF annotations**: `data/raw/genomic/gff/`
- **Summary reports**: `data/processed/genomic/`

---

*Report generated on `r Sys.time()`*

## Información de Sesión

```{r}
#| label: session-info
#| echo: true

sessionInfo()
```

---

**Nota**: Este reporte fue generado automáticamente usando el pipeline integrado de análisis de biodiversidad marina. Para más información sobre la metodología y código fuente, consultar el repositorio del proyecto.
